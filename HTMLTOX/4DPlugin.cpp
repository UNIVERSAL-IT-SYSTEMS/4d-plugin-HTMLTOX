/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : HTMLTOX
 #	author : miyako
 #	2015/11/19
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

namespace wkhtmltox
{

    typedef struct params
    {
        bool boolValue;
        wkhtmltopdf_converter *pdf_converter;
        wkhtmltoimage_converter *image_converter;
        wkhtmltopdf_global_settings *pdf_global_settings;
        wkhtmltoimage_global_settings *image_global_settings;
        const char *data;
    }params;
    
    bool isReady = false;
    
    //globals; the library runs on the main process, so lets prohibit paralell calls
    method_id_t methodId = 0;
    progress_id_t progressId = 0;
    process_number_t processId = 0;
    bool isRunning = false;
    //params for callback
    C_LONGINT intParam;
    C_TEXT stringParam;
    C_TEXT callbackType;

//not used; it seems impossible to execute a 4D user process from the main process by unfreeaing a monitor process
//we will start a new local process each time
    
    /*
    namespace listener
    {
        bool shouldTerminate = false;
        bool shouldExecute = false;
        progress_id_t processId = 0;
        C_TEXT processName;
    }
     */

#pragma mark PDF (callback)

    void pdf_progress_cb(wkhtmltopdf_converter * converter, const int val)
    {
//        NSLog(@"progress:%i", val);
        wkhtmltox::intParam.setIntValue(val);
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"progress", strlen("progress"));
        listenerLoopExecute();
    }

    void pdf_warning_cb(wkhtmltopdf_converter * converter, const char * str)
    {
//        NSLog(@"warning:%s", str);
        wkhtmltox::stringParam.setUTF8String((const uint8_t *)str, strlen(str));
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"warning", strlen("warning"));
        listenerLoopExecute();
    }

    void pdf_error_cb(wkhtmltopdf_converter * converter, const char * str)
    {
//        NSLog(@"error:%s", str);
        wkhtmltox::stringParam.setUTF8String((const uint8_t *)str, strlen(str));
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"error", strlen("error"));
        listenerLoopExecute();
    }
    
    void pdf_finished_cb(wkhtmltopdf_converter * converter, const int val)
    {
//        NSLog(@"finished:%i", val);
        wkhtmltox::intParam.setIntValue(val);
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"finished", strlen("finished"));
        listenerLoopExecute();
    }

#pragma mark Image (callback)

    void image_progress_cb(wkhtmltoimage_converter * converter, const int val)
    {
//        NSLog(@"progress:%i", val);
        wkhtmltox::intParam.setIntValue(val);
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"progress", strlen("progress"));
        listenerLoopExecute();
    }

    void image_warning_cb(wkhtmltoimage_converter * converter, const char * str)
    {
//        NSLog(@"warning:%s", str);
        wkhtmltox::stringParam.setUTF8String((const uint8_t *)str, strlen(str));
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"warning", strlen("warning"));
        listenerLoopExecute();
    }

    void image_error_cb(wkhtmltoimage_converter * converter, const char * str)
    {
//        NSLog(@"error:%s", str);
        wkhtmltox::stringParam.setUTF8String((const uint8_t *)str, strlen(str));
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"error", strlen("error"));
        listenerLoopExecute();
    }
    
    void image_finished_cb(wkhtmltoimage_converter * converter, const int val)
    {
//        NSLog(@"finished:%i", val);
        wkhtmltox::intParam.setIntValue(val);
        wkhtmltox::callbackType.setUTF8String((const uint8_t *)"finished", strlen("finished"));
        listenerLoopExecute();
    }

    namespace internal
    {
#pragma mark -
        void init()
        {
            wkhtmltopdf_init(0);
            wkhtmltoimage_init(0);
        }
#pragma mark PDF (internal)

        void pdf_create_converter(wkhtmltox::params *params)
        {
            params->pdf_converter = wkhtmltopdf_create_converter(params->pdf_global_settings);
        }

        void pdf_create_global_settings(wkhtmltox::params *params)
        {
            params->pdf_global_settings = wkhtmltopdf_create_global_settings();
        }

        void pdf_convert(wkhtmltox::params *params)
        {
            wkhtmltopdf_set_progress_changed_callback(params->pdf_converter,
            (wkhtmltopdf_int_callback)wkhtmltox::pdf_progress_cb);

            wkhtmltopdf_set_finished_callback(params->pdf_converter,
            (wkhtmltopdf_int_callback)wkhtmltox::pdf_finished_cb);

            wkhtmltopdf_set_warning_callback(params->pdf_converter,
            (wkhtmltopdf_str_callback)wkhtmltox::pdf_warning_cb);

            wkhtmltopdf_set_error_callback(params->pdf_converter,
            (wkhtmltopdf_str_callback)wkhtmltox::pdf_error_cb);
            
            params->boolValue = wkhtmltopdf_convert(params->pdf_converter);
        }
        
        void pdf_destroy_converter(wkhtmltox::params *params)
        {
            wkhtmltopdf_destroy_converter(params->pdf_converter);
        }

#pragma mark Image (internal)

        void image_create_converter(wkhtmltox::params *params)
        {
            params->image_converter = wkhtmltoimage_create_converter(params->image_global_settings, params->data);
        }

        void image_create_global_settings(wkhtmltox::params *params)
        {
            params->image_global_settings = wkhtmltoimage_create_global_settings();
        }
        
        void image_convert(wkhtmltox::params *params)
        {
        
            wkhtmltoimage_set_error_callback(params->image_converter,
            (wkhtmltoimage_str_callback)wkhtmltox::image_error_cb);
        
            wkhtmltoimage_set_warning_callback(params->image_converter,
            (wkhtmltoimage_str_callback)wkhtmltox::image_warning_cb);
        
            wkhtmltoimage_set_progress_changed_callback(params->image_converter,
            (wkhtmltoimage_int_callback)wkhtmltox::image_progress_cb);
        
            wkhtmltoimage_set_finished_callback(params->image_converter,
            (wkhtmltoimage_int_callback)wkhtmltox::image_finished_cb);
        
            params->boolValue = wkhtmltoimage_convert(params->image_converter);
        }
        
        void image_destroy_converter(wkhtmltox::params *params)
        {
            wkhtmltoimage_destroy_converter(params->image_converter);
        }
        
    }

#pragma mark PDF

    void pdf_create_converter(wkhtmltox::params *params)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::pdf_create_converter, params);
    }

    void pdf_create_global_settings(wkhtmltox::params *params)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::pdf_create_global_settings, params);
    }

    int pdf_convert(wkhtmltox::params *params)
    {
        listenerLoopStart();
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::pdf_convert, params);
        listenerLoopFinish();
        
        return params->boolValue;
    }
    
    void pdf_get_output(wkhtmltox::params *params, C_BLOB &returnValue)
    {
        const unsigned char *bytes;
        long len = wkhtmltopdf_get_output(params->pdf_converter, &bytes);
        returnValue.setBytes((const uint8_t *)bytes, len);
    }
    
    void pdf_destroy_converter(wkhtmltox::params *params)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::pdf_destroy_converter, params);
    }
    
#pragma mark Image
    
    void image_create_converter(wkhtmltox::params *params)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::image_create_converter, params);
    }
    
    void image_create_global_settings(wkhtmltox::params *params)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::image_create_global_settings, params);
    }
    
    int image_convert(wkhtmltox::params *params)
    {
        listenerLoopStart();
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::image_convert, params);
        listenerLoopFinish();
        
        return params->boolValue;
    }

    void image_get_output(wkhtmltox::params *params, C_BLOB &returnValue)
    {
        const unsigned char *bytes;
        long len = wkhtmltoimage_get_output(params->image_converter, &bytes);
        returnValue.setBytes((const uint8_t *)bytes, len);
    }
    
    void image_destroy_converter(wkhtmltox::params *params)
    {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::image_destroy_converter, params);
    }

#pragma mark -
    
    void init()
    {
         if(!wkhtmltox::isReady)
         {
             PA_RunInMainProcess((PA_RunInMainProcessProcPtr)wkhtmltox::internal::init, NULL);
             wkhtmltox::isReady = true;
         }
    }
    
#pragma mark -
    
    PA_long32 testPathName(CUTF8String &pathName)
    {
        PA_long32 resultCode = 0;
        
        PA_Variable params[1];
        params[0] = PA_CreateVariable(eVK_Unistring);
        
        C_TEXT temp;
        temp.setUTF8String(&pathName);
        
//        PA_Unistring ustr = PA_CreateUnistring((PA_Unichar *)temp.getUTF16StringPtr());
//        PA_SetStringVariable(&args[0], &ustr);
        
        PA_SetUnistring( (&(params[0].uValue.fString)), (PA_Unichar *)temp.getUTF16StringPtr());
        
        PA_Variable result = PA_ExecuteCommandByID(CMU_Test_path_name, params, 1);
        if(PA_GetVariableKind(result) == eVK_Longint)
        {
            resultCode = PA_GetLongintVariable(result);
        }
        
//        PA_DisposeUnistring(&ustr);

        PA_ClearVariable(&params[0]);
        
        return resultCode;
    }

#pragma mark -

    void setGlobalOptionForPDF(wkhtmltopdf_global_settings *settings, CUTF8String &optionName, CUTF8String &optionValue)
    {
        if(optionName.length())
        {
            size_t pos = optionName.find_first_of((const uint8_t *)":");
            if(pos == std::string::npos)
            {
                wkhtmltopdf_set_global_setting(settings, (const char *)optionName.c_str(), (const char *)optionValue.c_str());
            }
        }
    }

    void setGlobalOptionForImage(wkhtmltoimage_global_settings *settings, CUTF8String &optionName, CUTF8String &optionValue)
    {
        if(optionName.length())
        {
            wkhtmltoimage_set_global_setting(settings, (const char *)optionName.c_str(), (const char *)optionValue.c_str());
        }
    }

    void setPageOptionForPDF(wkhtmltopdf_object_settings *settings, int pageNum, CUTF8String &optionName, CUTF8String &optionValue)
    {
        if(optionName.length())
        {
            size_t pos = optionName.find_first_of((const uint8_t *)":");
            if(pos != std::string::npos)
            {
                CUTF8String prefix = optionName.substr(0, pos);
                if(atoi((const char *)prefix.c_str()) == pageNum)
                {
                CUTF8String realOptionName = optionName.substr(pos + 1);
                wkhtmltopdf_set_object_setting(settings, (const char *)realOptionName.c_str(), (const char *)optionValue.c_str());
                }
            }
        }
    }
}

#pragma mark -

bool IsProcessOnExit(){    
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    CUTF16String procName(name.getUTF16StringPtr());
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

//OnStartup and OnExit shall be executed in the main process

void OnStartup(){
//    init is deferred to first call
//    wkhtmltopdf_init(0);
//    wkhtmltoimage_init(0);
    
//    CUTF8String name((const uint8_t *)"$HTML_CONVERTER_II");
//    wkhtmltox::listener::processName.setUTF8String(&name);
}

void OnExit(){
//    can't deinit in plugin; the database may be closed but 4D can still be running...
//    wkhtmltopdf_deinit();
//    wkhtmltoimage_deinit();
}

void OnCloseProcess(){
    if(IsProcessOnExit()){
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)OnExit, NULL);
    }
}

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if VERSIONMAC
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
    returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
    CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
    NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
    returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif    
#else

#endif
}

#pragma mark -

void listenerLoop(){
/*
    wkhtmltox::listener::shouldExecute = false;
    wkhtmltox::listener::shouldTerminate = false;
        
    while(!wkhtmltox::listener::shouldTerminate)
    { 
        PA_YieldAbsolute();
        
        if(wkhtmltox::listener::shouldExecute){
            
            wkhtmltox::listener::shouldExecute = false;
            
            C_TEXT processName;
            generateUuid(processName);
            PA_NewProcess((void *)listenerLoopExecuteMethod, 
                          0,
                          (PA_Unichar *)processName.getUTF16StringPtr());        

        }

        if(!wkhtmltox::listener::shouldTerminate){
            PA_FreezeProcess(PA_GetCurrentProcessNumber());  
        }else{
            wkhtmltox::listener::processId = 0;
        }
    }
    PA_KillProcess();
    */
}

void listenerLoopStart()
{
/*
    if(!wkhtmltox::listener::processId){
        
        wkhtmltox::listener::processId = PA_NewProcess((void *)listenerLoop,
                                                         0,
                                                         (PA_Unichar *)wkhtmltox::listener::processName.getUTF16StringPtr());
     }
  */
}

void listenerLoopFinish(){
/*
    if(wkhtmltox::listener::processId)
    {
        //set flags
        wkhtmltox::listener::shouldTerminate = true;
        wkhtmltox::listener::shouldExecute = false;
        PA_YieldAbsolute();  
        //tell listener to die      
        while(wkhtmltox::listener::processId){
            PA_YieldAbsolute();
            PA_UnfreezeProcess(wkhtmltox::listener::processId);
        }
    }
  */
}

void listenerLoopExecute()
{
/*
    wkhtmltox::listener::shouldTerminate = false;
    wkhtmltox::listener::shouldExecute = true;
    PA_UnfreezeProcess(wkhtmltox::listener::processId);
    PA_YieldAbsolute();
  */
    C_TEXT processName;
    generateUuid(processName);
    PA_NewProcess((void *)listenerLoopExecuteMethod,
    0,
    (PA_Unichar *)"$\0H\0T\0M\0L\0T\0O\0X\0\0\0");
    PA_YieldAbsolute();
    PA_KillProcess();
}

void listenerLoopExecuteMethod(){
    
    if(wkhtmltox::methodId){
        
        PA_Variable	params[5];
        params[0] = PA_CreateVariable(eVK_Longint);
        params[1] = PA_CreateVariable(eVK_Longint);
        params[2] = PA_CreateVariable(eVK_Longint);
        params[3] = PA_CreateVariable(eVK_Unistring);
        params[4] = PA_CreateVariable(eVK_Unistring);
        
        PA_SetLongintVariable(&params[0], wkhtmltox::intParam.getIntValue());
        PA_SetLongintVariable(&params[1], wkhtmltox::processId);
        PA_SetLongintVariable(&params[2], wkhtmltox::progressId);
        
//        PA_Unistring stringParam = PA_CreateUnistring((PA_Unichar *)wkhtmltox::stringParam.getUTF16StringPtr());
//        PA_SetStringVariable(&params[3], &stringParam);
        PA_SetUnistring( (&(params[3].uValue.fString)), (PA_Unichar *)wkhtmltox::stringParam.getUTF16StringPtr());
        
//        PA_Unistring callbackType = PA_CreateUnistring((PA_Unichar *)wkhtmltox::callbackType.getUTF16StringPtr());
//        PA_SetStringVariable(&params[4], &callbackType);
        PA_SetUnistring( (&(params[4].uValue.fString)), (PA_Unichar *)wkhtmltox::callbackType.getUTF16StringPtr());
        
        PA_ExecuteMethodByID(wkhtmltox::methodId, params, 5);
        
//        PA_DisposeUnistring(&stringParam);
//        PA_DisposeUnistring(&callbackType);
        
        PA_ClearVariable(&params[0]);
        PA_ClearVariable(&params[1]);
        PA_ClearVariable(&params[2]);
        PA_ClearVariable(&params[3]);
        PA_ClearVariable(&params[4]);
    }
    
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
    PA_long32 pProcNum = selector;
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;

    CommandDispatcher(pProcNum, pResult, pParams);
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
    
        case kInitPlugin :
        case kServerInitPlugin :
//            OnStartup();
            break;

        case kCloseProcess :            
//            OnCloseProcess();
            break;
            
// --- HTMLTOX

		case 1 :
        {
            if(!wkhtmltox::isRunning)
            {
                wkhtmltox::isRunning = true;
                try
                {
                    HTML_Convert(pResult, pParams);
                }
                catch(...)
                {

                }
                wkhtmltox::isRunning = false;
            }
        }
			break;

	}
}

// ------------------------------------ HTMLTOX -----------------------------------

#pragma mark

void HTML_Convert(sLONG_PTR *pResult, PackagePtr pParams)
{
    wkhtmltox::init();
    
	ARRAY_TEXT inObjects;
	C_LONGINT inOutputFormat;
	ARRAY_TEXT inOptionName;
	ARRAY_TEXT inOptionValue;
	C_BLOB returnValue;

	inObjects.fromParamAtIndex(pParams, 1);
	inOutputFormat.fromParamAtIndex(pParams, 2);
	inOptionName.fromParamAtIndex(pParams, 3);
	inOptionValue.fromParamAtIndex(pParams, 4);

    wkhtmltox::processId = PA_GetCurrentProcessNumber();
    wkhtmltox::methodId = 0;
    wkhtmltox::progressId = 0;
    
    BOOL isOutputPDF = false;
    int outputFormat = inOutputFormat.getIntValue();

    switch (outputFormat)
    {
        case HTMLTOX_Format_PDF:
        case HTMLTOX_Format_PS:
        isOutputPDF = true;
        break;
        case HTMLTOX_Format_PNG:
        case HTMLTOX_Format_JPG:
        case HTMLTOX_Format_BMP:
        case HTMLTOX_Format_SVG:
        isOutputPDF = false;
        break;
        default:
        outputFormat = HTMLTOX_Format_PDF;
        isOutputPDF = true;
        break;
    };
    
    wkhtmltox::params params;
    
    if(isOutputPDF)
    {
        wkhtmltox::pdf_create_global_settings(&params);
    
        switch (outputFormat)
        {
            case HTMLTOX_Format_PDF:
                wkhtmltopdf_set_global_setting(params.pdf_global_settings, "outputFormat", "pdf");
            break;
            case HTMLTOX_Format_PS:
                wkhtmltopdf_set_global_setting(params.pdf_global_settings, "outputFormat", "ps");
            break;
            default:
            break;
        };
    }else
    {
        wkhtmltox::image_create_global_settings(&params);
        
        switch (outputFormat)
        {
            case HTMLTOX_Format_PNG:
                wkhtmltoimage_set_global_setting(params.image_global_settings, "fmt", "png");
            break;
            case HTMLTOX_Format_JPG:
                wkhtmltoimage_set_global_setting(params.image_global_settings, "fmt", "jpg");
            break;
            case HTMLTOX_Format_BMP:
                wkhtmltoimage_set_global_setting(params.image_global_settings, "fmt", "bmp");
            break;
            case HTMLTOX_Format_SVG:
                wkhtmltoimage_set_global_setting(params.image_global_settings, "fmt", "svg");
            break;
            default:
            break;
        };
    }

    size_t countOptions = inOptionName.getSize();
    
    if(countOptions == inOptionValue.getSize())
    {
        //starts from $array{0} in 4D language
        for(int i = 0; i < countOptions; ++i)
        {
            CUTF8String optionName;
            inOptionName.copyUTF8StringAtIndex(&optionName, i);
            CUTF8String optionValue;
            inOptionValue.copyUTF8StringAtIndex(&optionValue, i);
            
            if(optionName.find((const uint8_t *)"4d.progressId") == 0)
            {
                wkhtmltox::progressId = atoi((const char *)optionValue.c_str());
            }else
            if(optionName.find((const uint8_t *)"4d.callbackMethodName") == 0)
            {
                CUTF16String methodName;
                inOptionValue.copyUTF16StringAtIndex(&methodName, i);
                wkhtmltox::methodId = PA_GetMethodID((PA_Unichar *)methodName.c_str());
            }else
            {
                if(isOutputPDF)
                {
                    wkhtmltox::setGlobalOptionForPDF(params.pdf_global_settings, optionName, optionValue);
                }else
                {
                    wkhtmltox::setGlobalOptionForImage(params.image_global_settings, optionName, optionValue);
                }
            }

        }
        
        int countPages = inObjects.getSize();
        
        if(isOutputPDF)
        {
            wkhtmltox::pdf_create_converter(&params);
        }else
        {
            countPages = countPages ? 2 : 0;
        }
        
        //starts from $array{1} in 4D language
        for(int i = 1; i < countPages; ++i)
        {
            const char *data;
            CUTF8String htmlObject, htmlObject2;
            inObjects.copyUTF8StringAtIndex(&htmlObject, i);
            //object can be a url, a path, or html source
            BOOL isHtmlSource = true;
            if(
                (htmlObject.find((const uint8_t *)"http://") == 0)
              ||(htmlObject.find((const uint8_t *)"ftp://") == 0)
              ||(htmlObject.find((const uint8_t *)"https://") == 0)
              ||(htmlObject.find((const uint8_t *)"file://") == 0)
            )
            {
                data = (const char *)htmlObject.c_str();
                isHtmlSource = false;
            }else
            {
                if(CMK_Is_a_document == wkhtmltox::testPathName(htmlObject))
                {
                    #if VERSIONWIN
                        data = (const char *)htmlObject.c_str();
                    #else
                        NSString *str = inObjects.copyUTF16StringAtIndex(i);
                        NSURL *url = (NSURL *)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, (CFStringRef)str, kCFURLHFSPathStyle, false);
                        if(url)
                        {
                            NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)url, kCFURLPOSIXPathStyle);
                            C_TEXT temp;
                            temp.setUTF16String(path);
                            temp.copyUTF8String(&htmlObject2);
                            [path release];
                            [url release];
                        }
                        [str release];
                        data = (const char *)htmlObject2.c_str();
                    #endif
                    isHtmlSource = false;
                }
            }

            if(isOutputPDF)
            {
                wkhtmltopdf_object_settings *pdf_object_settings = wkhtmltopdf_create_object_settings();
                //starts from $array{0} in 4D language
                for(int j = 0; j < countOptions; ++j)
                {
                    CUTF8String optionName;
                    inOptionName.copyUTF8StringAtIndex(&optionName, j);
                    CUTF8String optionValue;
                    inOptionValue.copyUTF8StringAtIndex(&optionValue, j);
                    wkhtmltox::setPageOptionForPDF(pdf_object_settings, i, optionName, optionValue);
                }
                if(!isHtmlSource)
                {
                    wkhtmltopdf_set_object_setting(pdf_object_settings, "page", data);
                    wkhtmltopdf_add_object(params.pdf_converter, pdf_object_settings, NULL);
                }else
                {
                    wkhtmltopdf_add_object(params.pdf_converter, pdf_object_settings, (const char *)htmlObject.c_str());
                }
            }else
            {

                if(!isHtmlSource)
                {
                    params.data = NULL;
                    wkhtmltoimage_set_global_setting(params.image_global_settings, "in", data);
                    wkhtmltox::image_create_converter(&params);
                }else
                {
                    params.data = data;
                    wkhtmltox::image_create_converter(&params);
                }
                
                if(wkhtmltox::image_convert(&params))
                {
                    wkhtmltox::image_get_output(&params, returnValue);
                }
                wkhtmltox::image_destroy_converter(&params);
                
            }

        }
        
        if(isOutputPDF)
        {
            if(wkhtmltox::pdf_convert(&params))
            {
                wkhtmltox::pdf_get_output(&params, returnValue);
            }
            wkhtmltox::pdf_destroy_converter(&params);
        }
    }
	
	returnValue.setReturn(pResult);
}

